import os
import io
import base64
import re
from dotenv import load_dotenv
from datetime import date, timedelta
import logging

from fastapi import FastAPI, Depends, HTTPException, status, File, UploadFile, Form
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel
from sqlalchemy import create_engine, text
from sqlalchemy.engine.base import Engine

from supabase import create_client, Client
from gtts import gTTS
import speech_recognition as sr
from pydub import AudioSegment

from langchain.agents import AgentExecutor, create_tool_calling_agent
from langchain.tools import tool
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables.history import RunnableWithMessageHistory
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_community.chat_message_histories import ChatMessageHistory

# Import h√†m x·ª≠ l√Ω th·ªùi gian t·ª´ module utils
from utils.thoi_gian_tu_nhien import parse_natural_time

# --- 1. C·∫§U H√åNH & K·∫æT N·ªêI ---
load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
DATABASE_URL = os.getenv("DATABASE_URL")
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_ANON_KEY")

if not all([DATABASE_URL, SUPABASE_URL, SUPABASE_KEY, GEMINI_API_KEY]):
    raise ValueError("‚ùå Thi·∫øu c√°c bi·∫øn m√¥i tr∆∞·ªùng c·∫ßn thi·∫øt trong file .env")

engine: Engine = create_engine(DATABASE_URL, pool_pre_ping=True, pool_recycle=300)
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)
llm_brain = ChatGoogleGenerativeAI(model="gemini-2.5-flash", google_api_key=GEMINI_API_KEY, temperature=0.7)

# --- 2. X√ÅC TH·ª∞C NG∆Ø·ªúI D√ôNG ---
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def get_current_user_id(token: str = Depends(oauth2_scheme)) -> str:
    try:
        user_response = supabase.auth.get_user(token)
        user_id = user_response.user.id
        logger.info(f"üë§ User ID ƒë√£ x√°c th·ª±c: {user_id}")
        return str(user_id)
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.",
        )

# --- 3. C√ÅC H√ÄM X·ª¨ L√ù GI·ªåNG N√ìI (Gi·ªØ nguy√™n) ---
def clean_text_for_speech(text: str) -> str:
    cleaned_text = text.replace('*', '')
    cleaned_text = cleaned_text.replace('_', '')
    cleaned_text = re.sub(r'^\s*-\s*', '. ', cleaned_text, flags=re.MULTILINE)
    return cleaned_text

def text_to_base64_audio(text: str) -> str:
    try:
        speech_text = clean_text_for_speech(text)
        tts = gTTS(speech_text, lang='vi', slow=False)
        audio_fp = io.BytesIO()
        tts.write_to_fp(audio_fp)
        audio_fp.seek(0)
        audio_bytes = audio_fp.read()
        return base64.b64encode(audio_bytes).decode('utf-8')
    except Exception as e:
        logger.error(f"L·ªói TTS: {e}")
        return ""

async def audio_to_text(audio_file: UploadFile) -> str:
    r = sr.Recognizer()
    try:
        audio_bytes = await audio_file.read()
        audio_fp = io.BytesIO(audio_bytes)
        sound = AudioSegment.from_file(audio_fp)

        if len(sound) < 500:
            raise HTTPException(status_code=400, detail="File √¢m thanh qu√° ng·∫Øn. Vui l√≤ng nh·∫•n gi·ªØ n√∫t micro ƒë·ªÉ n√≥i.")

        wav_fp = io.BytesIO()
        sound.export(wav_fp, format="wav")
        wav_fp.seek(0)

        with sr.AudioFile(wav_fp) as source:
            audio_data = r.record(source)
            try:
                text = r.recognize_google(audio_data, language="vi-VN")
                logger.info(f"üé§ VƒÉn b·∫£n nh·∫≠n d·∫°ng ƒë∆∞·ª£c: {text}")
                return text
            except sr.UnknownValueError:
                raise HTTPException(status_code=400, detail="R·∫•t ti·∫øc, t√¥i kh√¥ng nghe r√µ b·∫°n n√≥i. Vui l√≤ng th·ª≠ n√≥i ch·∫≠m v√† r√µ r√†ng h∆°n.")
            except sr.RequestError as e:
                raise HTTPException(status_code=503, detail=f"D·ªãch v·ª• nh·∫≠n d·∫°ng gi·ªçng n√≥i t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng. L·ªói: {e}")

    except Exception as e:
        if isinstance(e, HTTPException):
            raise e
        logger.error(f"L·ªói x·ª≠ l√Ω audio: {e}")
        raise HTTPException(status_code=500, detail=f"ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën khi x·ª≠ l√Ω file √¢m thanh.")

# --- 4. H√ÄM H·ªñ TR·ª¢ NGHI·ªÜP V·ª§ (M·ªöI) ---

def _get_task_id_from_title(connection, user_id: str, title: str) -> int | None:
    """
    H√†m n·ªôi b·ªô t√¨m task_id d·ª±a tr√™n ti√™u ƒë·ªÅ.
    ∆Øu ti√™n t√¨m task ch∆∞a ho√†n th√†nh v√† kh·ªõp nh·∫•t.
    """
    # 1. Th·ª≠ t√¨m kh·ªõp ch√≠nh x√°c (case-insensitive)
    query_exact = text("SELECT id FROM tasks WHERE user_id = :user_id AND lower(title) = lower(:title) ORDER BY is_completed ASC, created_at DESC LIMIT 1;")
    result = connection.execute(query_exact, {"user_id": user_id, "title": title}).fetchone()
    if result:
        return result.id

    # 2. Th·ª≠ t√¨m kh·ªõp ILIKE (ch·ª©a)
    query_like = text("SELECT id FROM tasks WHERE user_id = :user_id AND unaccent(title) ILIKE unaccent(:title_like) ORDER BY is_completed ASC, created_at DESC LIMIT 1;")
    result = connection.execute(query_like, {"user_id": user_id, "title_like": f"%{title}%"}).fetchone()
    if result:
        return result.id
    
    return None

# --- 5. C√ÅC C√îNG C·ª§ (TOOLS) CHO AGENT (N√ÇNG C·∫§P) ---

@tool
def lay_ten_nguoi_dung(user_id: str) -> str:
    """L·∫•y t√™n c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i t·ª´ c∆° s·ªü d·ªØ li·ªáu ƒë·ªÉ c√° nh√¢n h√≥a cu·ªôc tr√≤ chuy·ªán."""
    try:
        with engine.connect() as connection:
            query = text("SELECT name FROM public.profiles WHERE id = :user_id;")
            result = connection.execute(query, {"user_id": user_id}).fetchone()
            if result and result.name:
                return f"T√™n c·ªßa ng∆∞·ªùi d√πng l√† {result.name}."
            else:
                return "Kh√¥ng t√¨m th·∫•y t√™n ng∆∞·ªùi d√πng. C·ª© tr·∫£ l·ªùi b√¨nh th∆∞·ªùng m√† kh√¥ng c·∫ßn g·ªçi t√™n."
    except Exception as e:
        return f"L·ªói khi l·∫•y t√™n ng∆∞·ªùi d√πng: {e}. C·ª© tr·∫£ l·ªùi b√¨nh th∆∞·ªùng."

@tool
def tao_task_don_le(tieu_de: str, user_id: str, mo_ta: str | None = None, deadline: str | None = None, priority: str | None = None) -> str:
    """
    T·∫°o m·ªôt C√îNG VI·ªÜC (task) m·ªõi m√† KH√îNG c·∫ßn l·ªãch tr√¨nh (schedule) c·ª• th·ªÉ.
    Ch·ªâ d√πng khi ng∆∞·ªùi d√πng n√≥i 't·∫°o task', 'th√™m vi·ªác c·∫ßn l√†m', 't·∫°o nhi·ªám v·ª•', 'deadline'.
    Kh√¥ng d√πng khi ng∆∞·ªùi d√πng n√≥i 'ƒë·∫∑t l·ªãch', 'h·∫πn'.
    priority ph·∫£i l√† m·ªôt trong ['low', 'medium', 'high'].
    """
    try:
        # X·ª≠ l√Ω deadline (n·∫øu c√≥)
        deadline_iso = None
        if deadline:
            parsed_time = parse_natural_time(deadline)
            deadline_iso = parsed_time[0].isoformat() # L·∫•y start_time l√†m deadline

        with engine.connect() as connection:
            with connection.begin() as transaction:
                query = text("""
                    INSERT INTO tasks (user_id, title, description, deadline, priority, status)
                    VALUES (:user_id, :title, :description, :deadline, :priority, 'todo')
                    RETURNING id;
                """)
                result = connection.execute(
                    query,
                    {
                        "user_id": user_id,
                        "title": tieu_de,
                        "description": mo_ta,
                        "deadline": deadline_iso,
                        "priority": priority if priority in ['low', 'medium', 'high'] else None
                    }
                )
                task_id = result.scalar_one_or_none()
                transaction.commit()
                return f"‚úÖ ƒê√£ t·∫°o c√¥ng vi·ªác m·ªõi: '{tieu_de}' (ID: {task_id})."
    except Exception as e:
        return f"‚ùå L·ªói khi t·∫°o c√¥ng vi·ªác: {e}"

@tool
def tao_lich_trinh(tieu_de: str, thoi_gian_bat_dau: str, thoi_gian_ket_thuc: str, user_id: str) -> str:
    """
    T·∫°o m·ªôt L·ªäCH TR√åNH (schedule) M·ªöI.
    D√πng khi ng∆∞·ªùi d√πng n√≥i 'ƒë·∫∑t l·ªãch', 'th√™m l·ªãch h·∫πn', 't·∫°o s·ª± ki·ªán'.
    H√†m n√†y s·∫Ω t·ª± ƒë·ªông t·∫°o m·ªôt C√îNG VI·ªÜC (task) v√† m·ªôt L·ªäCH TR√åNH (schedule) li√™n k·∫øt v·ªõi nhau.
    """
    try:
        with engine.connect() as connection:
            with connection.begin() as transaction:
                # 1. T·∫°o task tr∆∞·ªõc
                task_query = text("""
                    INSERT INTO tasks (user_id, title, status) 
                    VALUES (:user_id, :title, 'todo') 
                    RETURNING id;
                """)
                result = connection.execute(task_query, {"user_id": user_id, "title": tieu_de})
                task_id = result.scalar_one_or_none()
                if not task_id:
                    raise Exception("Kh√¥ng th·ªÉ t·∫°o task li√™n k·∫øt.")

                # 2. T·∫°o schedule li√™n k·∫øt v·ªõi task_id
                schedule_query = text("""
                    INSERT INTO schedules (user_id, task_id, start_time, end_time) 
                    VALUES (:user_id, :task_id, :start_time, :end_time);
                """)
                connection.execute(
                    schedule_query,
                    {
                        "user_id": user_id,
                        "task_id": task_id,
                        "start_time": thoi_gian_bat_dau,
                        "end_time": thoi_gian_ket_thuc
                    }
                )
                transaction.commit()
                return f"‚úÖ ƒê√£ l√™n l·ªãch '{tieu_de}' l√∫c {thoi_gian_bat_dau}."
    except Exception as e:
        return f"‚ùå L·ªói khi t·∫°o l·ªãch tr√¨nh: {e}"

@tool
def tao_ghi_chu(noi_dung: str, user_id: str, task_tieu_de: str | None = None) -> str:
    """
    T·∫°o m·ªôt GHI CH√ö (note) m·ªõi.
    N·∫øu `task_tieu_de` ƒë∆∞·ª£c cung c·∫•p, ghi ch√∫ s·∫Ω ƒë∆∞·ª£c li√™n k·∫øt v·ªõi c√¥ng vi·ªác ƒë√≥.
    N·∫øu kh√¥ng, ghi ch√∫ s·∫Ω ƒë∆∞·ª£c t·∫°o ƒë·ªôc l·∫≠p.
    """
    try:
        task_id = None
        with engine.connect() as connection:
            with connection.begin() as transaction:
                if task_tieu_de:
                    task_id = _get_task_id_from_title(connection, user_id, task_tieu_de)
                    if not task_id:
                        return f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác '{task_tieu_de}' ƒë·ªÉ ƒë√≠nh k√®m ghi ch√∫."

                query = text("""
                    INSERT INTO notes (user_id, content, task_id) 
                    VALUES (:user_id, :content, :task_id);
                """)
                connection.execute(query, {"user_id": user_id, "content": noi_dung, "task_id": task_id})
                transaction.commit()
                
                if task_id:
                    return f"‚úÖ ƒê√£ t·∫°o ghi ch√∫ v√† ƒë√≠nh k√®m v√†o c√¥ng vi·ªác '{task_tieu_de}'."
                else:
                    return f"‚úÖ ƒê√£ t·∫°o ghi ch√∫ m·ªõi."
    except Exception as e:
        return f"‚ùå L·ªói khi t·∫°o ghi ch√∫: {e}"

@tool
def them_muc_vao_checklist(task_tieu_de: str, noi_dung_muc: str, user_id: str) -> str:
    """Th√™m m·ªôt m·ª•c (item) m·ªõi v√†o CHECKLIST c·ªßa m·ªôt C√îNG VI·ªÜC (task) ƒë√£ c√≥."""
    try:
        with engine.connect() as connection:
            with connection.begin() as transaction:
                task_id = _get_task_id_from_title(connection, user_id, task_tieu_de)
                if not task_id:
                    return f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác '{task_tieu_de}' ƒë·ªÉ th√™m checklist."
                
                query = text("""
                    INSERT INTO checklist_items (task_id, content, is_checked)
                    VALUES (:task_id, :content, FALSE);
                """)
                connection.execute(query, {"task_id": task_id, "content": noi_dung_muc})
                transaction.commit()
                return f"‚úÖ ƒê√£ th√™m '{noi_dung_muc}' v√†o checklist c·ªßa c√¥ng vi·ªác '{task_tieu_de}'."
    except Exception as e:
        return f"‚ùå L·ªói khi th√™m checklist: {e}"

@tool
def xoa_task_hoac_lich_trinh(tieu_de: str, user_id: str) -> str:
    """
    X√≥a m·ªôt C√îNG VI·ªÜC (task) ho·∫∑c L·ªäCH TR√åNH (schedule) d·ª±a tr√™n ti√™u ƒë·ªÅ.
    Do CSDL thi·∫øt k·∫ø ON DELETE CASCADE, x√≥a task s·∫Ω t·ª± ƒë·ªông x√≥a schedule, checklist, reminder li√™n quan.
    """
    try:
        with engine.connect() as connection:
            with connection.begin() as transaction:
                task_id = _get_task_id_from_title(connection, user_id, tieu_de)
                if not task_id:
                    return f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y '{tieu_de}' ƒë·ªÉ x√≥a."

                query = text("DELETE FROM tasks WHERE id = :task_id;")
                result = connection.execute(query, {"task_id": task_id})
                transaction.commit()
                
                if result.rowcount > 0:
                    return f"üóëÔ∏è ƒê√£ x√≥a th√†nh c√¥ng '{tieu_de}' v√† t·∫•t c·∫£ d·ªØ li·ªáu li√™n quan."
                else:
                    return f"‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a '{tieu_de}'."
    except Exception as e:
        return f"‚ùå L·ªói khi x√≥a: {e}"

@tool
def tim_lich_trinh(ngay_bat_dau: str, ngay_ket_thuc: str, user_id: str) -> str:
    """T√¨m c√°c l·ªãch tr√¨nh trong m·ªôt kho·∫£ng ng√†y ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh cho m·ªôt user c·ª• th·ªÉ."""
    try:
        with engine.connect() as connection:
            query = text("""
                SELECT t.title, s.start_time 
                FROM schedules s 
                JOIN tasks t ON s.task_id = t.id 
                WHERE s.user_id = :user_id 
                AND s.start_time::date BETWEEN :start_date AND :end_date 
                ORDER BY s.start_time LIMIT 10;
            """)
            results = connection.execute(query, {"user_id": user_id, "start_date": ngay_bat_dau, "end_date": ngay_ket_thuc}).fetchall()
            if not results:
                return f"üì≠ B·∫°n kh√¥ng c√≥ l·ªãch tr√¨nh n√†o t·ª´ {ngay_bat_dau} ƒë·∫øn {ngay_ket_thuc}."
            events = [f"- '{row.title}' l√∫c {row.start_time.strftime('%H:%M ng√†y %d/%m/%Y')}" for row in results]
            return f"üîé B·∫°n c√≥ {len(events)} l·ªãch tr√¨nh:\n" + "\n".join(events)
    except Exception as e:
        return f"‚ùå L·ªói khi t√¨m l·ªãch: {e}"

@tool
def doi_lich_trinh(tieu_de_cu: str, thoi_gian_moi: str, user_id: str) -> str:
    """Ch·ªânh s·ª≠a th·ªùi gian c·ªßa m·ªôt L·ªäCH TR√åNH (schedule) ƒë√£ c√≥."""
    try:
        with engine.connect() as connection:
            with connection.begin() as transaction:
                find_query = text("""
                    SELECT t.id, s.start_time 
                    FROM tasks t 
                    JOIN schedules s ON t.id = s.task_id 
                    WHERE t.user_id = :user_id AND unaccent(t.title) ILIKE unaccent(:title_like)
                    ORDER BY t.is_completed ASC, s.start_time DESC
                    LIMIT 1;
                """)
                original_task = connection.execute(find_query, {"user_id": user_id, "title_like": f"%{tieu_de_cu}%"}).fetchone()
                
                if not original_task:
                    return f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y l·ªãch tr√¨nh '{tieu_de_cu}' ƒë·ªÉ d·ªùi."

                task_id, old_start_time = original_task.id, original_task.start_time
                new_start, new_end = parse_natural_time(thoi_gian_moi, base_date=old_start_time)

                update_query = text("UPDATE schedules SET start_time = :start_time, end_time = :end_time WHERE task_id = :task_id;")
                result = connection.execute(update_query, {"start_time": new_start, "end_time": new_end, "task_id": task_id})
                transaction.commit()

                if result.rowcount > 0:
                    return f"‚úÖ ƒê√£ d·ªùi '{tieu_de_cu}' sang {new_start.strftime('%H:%M %d/%m/%Y')}."
                else:
                    return f"‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t '{tieu_de_cu}'."
    except Exception as e:
        return f"‚ùå L·ªói khi ch·ªânh s·ª≠a: {e}"

@tool
def danh_dau_task_hoan_thanh(tieu_de: str, user_id: str) -> str:
    """ƒê√°nh d·∫•u m·ªôt C√îNG VI·ªÜC (task) l√† ƒë√£ ho√†n th√†nh (is_completed = TRUE)."""
    try:
        with engine.connect() as connection:
            with connection.begin() as transaction:
                task_id = _get_task_id_from_title(connection, user_id, tieu_de)
                if not task_id:
                    return f"ü§î Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác n√†o c√≥ t√™n '{tieu_de}' ƒë·ªÉ ƒë√°nh d·∫•u."

                query = text("UPDATE tasks SET is_completed = TRUE, status = 'done' WHERE id = :task_id;")
                result = connection.execute(query, {"task_id": task_id})
                transaction.commit()

                if result.rowcount > 0:
                    return f"üëç R·∫•t t·ªët! ƒê√£ ƒë√°nh d·∫•u '{tieu_de}' l√† ƒë√£ ho√†n th√†nh."
                else:
                    return f"‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t '{tieu_de}'."
    except Exception as e:
        return f"‚ùå L·ªói khi ƒë√°nh d·∫•u ho√†n th√†nh: {e}"

@tool
def gan_the_vao_task(task_tieu_de: str, ten_the: str, user_id: str) -> str:
    """G·∫Øn m·ªôt TH·∫∫ (tag) v√†o m·ªôt C√îNG VI·ªÜC (task) ƒë√£ c√≥."""
    try:
        with engine.connect() as connection:
            with connection.begin() as transaction:
                task_id = _get_task_id_from_title(connection, user_id, task_tieu_de)
                if not task_id:
                    return f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác '{task_tieu_de}' ƒë·ªÉ g·∫Øn th·∫ª."

                # T√¨m ho·∫∑c t·∫°o th·∫ª (tag)
                tag_query = text("""
                    INSERT INTO tags (user_id, name) 
                    VALUES (:user_id, :name) 
                    ON CONFLICT (user_id, name) DO UPDATE SET name = EXCLUDED.name 
                    RETURNING id;
                """)
                tag_id = connection.execute(tag_query, {"user_id": user_id, "name": ten_the}).scalar_one()

                # G·∫Øn th·∫ª v√†o task
                task_tag_query = text("""
                    INSERT INTO task_tags (task_id, tag_id)
                    VALUES (:task_id, :tag_id)
                    ON CONFLICT (task_id, tag_id) DO NOTHING;
                """)
                connection.execute(task_tag_query, {"task_id": task_id, "tag_id": tag_id})
                transaction.commit()
                return f"‚úÖ ƒê√£ g·∫Øn th·∫ª '{ten_the}' cho c√¥ng vi·ªác '{task_tieu_de}'."
    except Exception as e:
        return f"‚ùå L·ªói khi g·∫Øn th·∫ª: {e}"

@tool
def tom_tat_tien_do(user_id: str) -> str:
    """Cung c·∫•p t√≥m t·∫Øt v·ªÅ l·ªãch tr√¨nh v√† c√¥ng vi·ªác c·ªßa ng∆∞·ªùi d√πng. D√πng khi ng∆∞·ªùi d√πng h·ªèi chung chung."""
    try:
        with engine.connect() as connection:
            total_query = text("SELECT COUNT(*) FROM tasks WHERE user_id = :user_id;")
            total_tasks = connection.execute(total_query, {"user_id": user_id}).scalar_one()

            completed_query = text("SELECT COUNT(*) FROM tasks WHERE user_id = :user_id AND is_completed = TRUE;")
            completed_tasks = connection.execute(completed_query, {"user_id": user_id}).scalar_one()
            
            todo_tasks = total_tasks - completed_tasks

            upcoming_query = text("""
                SELECT t.title, s.start_time 
                FROM schedules s 
                JOIN tasks t ON s.task_id = t.id 
                WHERE s.user_id = :user_id AND s.start_time > NOW() AND t.is_completed = FALSE 
                ORDER BY s.start_time ASC LIMIT 3;
            """)
            upcoming_results = connection.execute(upcoming_query, {"user_id": user_id}).fetchall()

            summary = f"T·ªïng quan c·ªßa b·∫°n:\n- üìä B·∫°n c√≥ t·ªïng c·ªông {total_tasks} c√¥ng vi·ªác.\n- ‚úÖ {completed_tasks} ƒë√£ ho√†n th√†nh.\n- ‚è≥ {todo_tasks} ch∆∞a ho√†n th√†nh.\n"
            if upcoming_results:
                summary += "- üóìÔ∏è C√°c l·ªãch tr√¨nh ch∆∞a ho√†n th√†nh s·∫Øp t·ªõi:\n" + "\n".join([f"  - '{row.title}' l√∫c {row.start_time.strftime('%H:%M %d/%m')}" for row in upcoming_results])
            else:
                summary += "- üóìÔ∏è B·∫°n kh√¥ng c√≥ l·ªãch tr√¨nh n√†o s·∫Øp t·ªõi ho·∫∑c t·∫•t c·∫£ ƒë·ªÅu ƒë√£ ho√†n th√†nh."
            return summary
    except Exception as e:
        return f"‚ùå L·ªói khi t√≥m t·∫Øt: {e}"

# --- 6. L·∫ÆP R√ÅP AGENT & B·ªò NH·ªö ---
tools_list = [
    lay_ten_nguoi_dung,
    tao_lich_trinh,
    tao_task_don_le,
    tao_ghi_chu,
    them_muc_vao_checklist,
    gan_the_vao_task,
    xoa_task_hoac_lich_trinh,
    tim_lich_trinh,
    doi_lich_trinh,
    danh_dau_task_hoan_thanh,
    tom_tat_tien_do
]

today = date.today()
system_prompt_template = f"""
B·∫°n l√† m·ªôt tr·ª£ l√Ω AI qu·∫£n l√Ω c√¥ng vi·ªác v√† l·ªãch tr√¨nh c√° nh√¢n t√™n l√† Skedule.
B·ªêI C·∫¢NH: H√¥m nay l√† {today.strftime('%A, %d/%m/%Y')}.
QUY T·∫ÆC NGHI·ªÜP V·ª§ (R·∫•t quan tr·ªçng):
1.  **Ph√¢n bi·ªát r√µ r√†ng:**
    * 'L·ªãch tr√¨nh', 'l·ªãch h·∫πn', 's·ª± ki·ªán' (v√≠ d·ª•: "h·∫πn b√°c sƒ© l√∫c 5h") => D√πng tool `tao_lich_trinh`. C·∫ßn c√≥ th·ªùi gian b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c.
    * 'C√¥ng vi·ªác', 'task', 'nhi·ªám v·ª•', 'deadline' (v√≠ d·ª•: "t·∫°o task n·ªôp b√†i t·∫≠p") => D√πng tool `tao_task_don_le`. Kh√¥ng nh·∫•t thi·∫øt c·∫ßn gi·ªù c·ª• th·ªÉ.
    * 'Ghi ch√∫', 'note', 'l∆∞u l·∫°i' (v√≠ d·ª•: "l∆∞u √Ω t∆∞·ªüng n√†y") => D√πng tool `tao_ghi_chu`.
    * 'Th√™m m·ª•c', 'checklist' (v√≠ d·ª•: "th√™m 'mua s·ªØa' v√†o task 'ƒëi ch·ª£'") => D√πng tool `them_muc_vao_checklist`.
    * 'G·∫Øn th·∫ª', 'tag' (v√≠ d·ª•: "g·∫Øn th·∫ª '∆∞u ti√™n' cho task 'l√†m slide'") => D√πng tool `gan_the_vao_task`.
    * 'Xong', 'ho√†n th√†nh' (v√≠ d·ª•: "ƒë√°nh d·∫•u 'l√†m slide' l√† xong") => D√πng tool `danh_dau_task_hoan_thanh`.
    * 'X√≥a', 'h·ªßy' (v√≠ d·ª•: "x√≥a l·ªãch h·ªçp 5h") => D√πng tool `xoa_task_hoac_lich_trinh`.
    * 'D·ªùi', 'ƒë·ªïi' (v√≠ d·ª•: "d·ªùi l·ªãch h·ªçp sang 6h") => D√πng tool `doi_lich_trinh`.
    * 'T√¨m', 'c√≥ g√¨' (v√≠ d·ª•: "ng√†y mai t√¥i c√≥ g√¨") => D√πng tool `tim_lich_trinh`.

2.  **Lu√¥n g·ªçi tool:** Lu√¥n s·ª≠ d·ª•ng c√°c c√¥ng c·ª• (tools) ƒë·ªÉ th·ª±c hi·ªán c√°c y√™u c·∫ßu tr√™n.
3.  **Ch√†o h·ªèi:** Khi b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán ho·∫∑c khi ch√†o h·ªèi, h√£y lu√¥n th·ª≠ g·ªçi tool `lay_ten_nguoi_dung` tr∆∞·ªõc ti√™n.
4.  **S·ª≠ d·ª•ng user_id:** Lu√¥n s·ª≠ d·ª•ng `user_id` ƒë∆∞·ª£c cung c·∫•p trong prompt ƒë·ªÉ g·ªçi tool.
5.  **ƒê·ªãnh d·∫°ng ng√†y:** Khi g·ªçi tool `tim_lich_trinh`, B·∫ÆT BU·ªòC ph·∫£i truy·ªÅn ng√†y th√°ng theo ƒë·ªãnh d·∫°ng 'YYYY-MM-DD'.
6.  **Di·ªÖn gi·∫£i k·∫øt qu·∫£:** Sau khi tool ch·∫°y xong, h√£y di·ªÖn gi·∫£i k·∫øt qu·∫£ ƒë√≥ (v√≠ d·ª•: "‚úÖ ƒê√£ t·∫°o...") th√†nh m·ªôt c√¢u tr·∫£ l·ªùi t·ª± nhi√™n, ƒë·∫ßy ƒë·ªß v√† l·ªãch s·ª± cho ng∆∞·ªùi d√πng.
"""
prompt = ChatPromptTemplate.from_messages([
    ("system", system_prompt_template),
    MessagesPlaceholder(variable_name="chat_history"),
    ("human", "USER_ID: {user_id}\n\nPROMPT: {input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad"),
])
agent = create_tool_calling_agent(llm_brain, tools_list, prompt)
agent_executor = AgentExecutor(agent=agent, tools=tools_list, verbose=True)
store = {}
def get_session_history(session_id: str) -> BaseChatMessageHistory:
    if session_id not in store:
        store[session_id] = ChatMessageHistory()
    return store[session_id]
agent_with_chat_history = RunnableWithMessageHistory(
    agent_executor, get_session_history,
    input_messages_key="input",
    history_messages_key="chat_history",
    input_messages_and_history_passthrough=True,
)

# --- 7. API SERVER ---
app = FastAPI(title="Skedule AI Agent API", version="3.0.0 (Full SRS)")

class ChatResponse(BaseModel):
    user_prompt: str | None = None
    text_response: str
    audio_base64: str

@app.get("/")
def read_root():
    return {"message": "Skedule AI Agent (Full SRS) is running!"}

@app.post("/chat", response_model=ChatResponse)
async def handle_chat_request(
    prompt: str | None = Form(None),
    audio_file: UploadFile | None = File(None),
    user_id: str = Depends(get_current_user_id)
):
    user_prompt = ""
    if audio_file:
        user_prompt = await audio_to_text(audio_file)
    elif prompt:
        user_prompt = prompt
    else:
        raise HTTPException(status_code=400, detail="C·∫ßn cung c·∫•p prompt d·∫°ng vƒÉn b·∫£n ho·∫∑c file √¢m thanh.")

    session_id = f"user_{user_id}"
    logger.info(f"üì® Prompt nh·∫≠n t·ª´ user {user_id}: {user_prompt}")

    final_result = agent_with_chat_history.invoke(
        {"input": user_prompt, "user_id": user_id},
        config={"configurable": {"session_id": session_id}}
    )
    ai_text_response = final_result.get("output", "L·ªói: Kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ agent.")

    ai_audio_base64 = text_to_base64_audio(ai_text_response)

    return ChatResponse(
        user_prompt=user_prompt if audio_file else None,
        text_response=ai_text_response,
        audio_base64=ai_audio_base64
    )
